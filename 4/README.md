# Лабораторная работа №4

## Задание

Реализовать структуры данных Разреженный вектор и Разреженная матрица и операции над ними.

## Решение

### Общая идея 

Для хранения ненулевых элементов разреженного вектора или матрицы можно использовать хэш-таблицу, где отсутствующие элементы не занимают память, к тому же доступ к элементам такой таблицы занимает константное время О(1).

### Запуск

`make build` для компиляции тестирующего функционал кода [main.cpp](main.cpp)

`make performance` для компиляции тестирующего производительность кода [performance.cpp](performance.cpp)

### Разреженный вектор

[sparse_vector.hpp](sparse_vector.hpp)

Для хранения ненулевых значений будем использовать `unordered_map` из стандартной библиотеки C++.

Сложность алгоритмов в среднем:
- Сложение и умножение на скаляр: `O(N)`, где N - количество ненулевых элементов вектора
- Сложение двух векторов: `O(X + Y)`, где X и Y - количества ненулевых элементов складываемых векторов
- Скалярное произведение с вектором: `O(N)`, где N - количество ненулевых элементов вектора на котором вызывается операция


### Разреженная матрица

[sparse_matrix.hpp](sparse_matrix.hpp)

Для хранения ненулевых значений будем использовать `unordered_map` из стандартной библиотеки C++.

Сложность алгоритмов следующая:
- Сложение и умножение на скаляр: `O(N)`, где N - количество ненулевых элементов матрицы
- Сложение двух матриц: `O(X + Y)`, где X и Y - количества ненулевых элементов складываемых матриц
- Произведение двух матриц размеров MxN и NxK: `O(M * N * K)`

## Заключение

В ходе л.р. были реализованы структуры разреженных вектора и матрицы.

С использованием хэш-таблицы удалось реализовать хранение только значимых (ненулевых) элементов.

Такой подход может быть эффективен как с точки зрения памяти, так и с точки зрения времени в случае, когда количество ненулевых элементов сильно меньше объема структуры. С другой стороны, при больших размерах структур и высокой плотности ненулевых элементов, разреженные структуры начинают сильно уступать полносвязным структурам из-за накладных расходов по работе с хэш-таблицами и отсутствия локальности данных.