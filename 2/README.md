# Лабораторная работа №2

Необходимо спроектировать класс, реализующий хранение данных, связанных с экземпляром класса в динамической памяти. Это может быть, например представление целых чисел, для которых помимо значения типа int хранится строковое представление числа (22 и «двадцать два»). Пример условен. 

Для данного класса необходимо реализовать все необходимые конструкторы, включая конструкторы копирования и перемещения, деструктор. Все конструкторы и деструктор должны «сообщать» о своём вызове. `std::cout << “Copy constructor” << std::endl;` то же относится и к перегрузке операции присваивания (два варианта: без перемещения и с перемещением).

Определение класса должно быть помещено в заголовочный файл (.hpp), реализация методов в отдельном файле .cpp.

Написать программу (ещё один модуль cpp) осуществляющую работу с экземплярами разработанного класса, которая должна демонстрировать:

- создание статических и динамических экземпляра класса, стандартного вектора в стиле Си, написать функцию для обработки данного вектора;
- передача экземпляров класса в функцию, и возврат экземпляра из функции; включая вариант с передачей и возвратом значений типа ссылки на класс;
- продемонстрировать работу с разработанным классом, создавая вектора и списки экземпляров класса, используя стандартные классы vector и list длиной от 5 до 10.


Проанализировать процессы создания и удаления экземпляров класса для различных примеров. Необходимо получить вывод от всех конструкторов, деструктора и перегруженных операций присваивания.

Представить отчёт о проделанной работе с выводами по результатам запуска программ.

## Решение

### Состав
Решение представлено тремя модулями

- `strint.(hpp|cpp)` - модуль, содержащий в себе разрабатываемый класс
- `char_utils.(hpp|cpp)` - модуль работы со строками
- `main.cpp` - исполняемый модуль с кодом тестирования разработанного класса

### Компиляция программы

```
make build
```

## Анализ полученного вывода

1. Создание статического объекта через перегруженный параметризованный конструктор.

```
creating static object
parameterized constructor called
```

Вызывается параметризованный конструктор.

2. Объявление нестатического объекта через пустой конструктор.

```
creating non-static object
empty constructor called
```
Вызывается конструктор без параметров.

3. Создание нестатического объекта через перегруженный параметризованный конструктор.
```
creating non-static object + init
parameterized constructor called
```
Вызывается параметризованный конструктор.

4. Инициализация С-вектора размера 3.

```
init vector
empty constructor called
empty constructor called
empty constructor called
```

Для каждого объекта вызывается констурктор без параметров.

5. Передача в функцию в качестве параметра.

```
passing to function
copy constructor called
one
destructor called
```
Вызов конструктора копирования и вызов деструктора по выходе из функции.


6. Передача в функцию в качестве параметра (по ссылке)

```
passing to function ref
one
```

Так как объект передается по ссылке никаких копирований не осуществляется.

7. Возврат из функции.

```
return from function
parameterized constructor called
three
destructor called
```

Внутри функции вызывается параметризованный конструктор и объект возвращается caller'у. Затем на временном объекте вызывается функция, после чего он уничтожается. Конструктор копирования не вызывается из-за RVO.

8. Возврат ссылки на статический объект из функции


```
return from function ref
parameterized constructor called
two
```

Вызывается конструктор при создании объекта, деструктор не вызывается, т.к статический объект продолжает жить вне контекста функции.

9. Move-семантика: move-конструктор при вызове std::move.

```
move constructor: std::move
parameterized constructor called
move constructor called
assignment with move operator called
twenty-two
```

Из-за `std::move` происходит перемещение через вызов move-конструктора. Строчка `assignment with move operator called` выводится из-за того, что move-констурктор реализован через оператор присваивания с перемещением как `*this = std::move(other)` чтобы избежать повторения в коде. На самом деле оператор присваивания не вызывается компилятором.

10. Move-семантика: move-конструктор при присваивании временного объекта

```
move constructor: temp value assignment
parameterized constructor called
```

Конструктор перемещения в данном случае не вызывается из-за RVO.

11. Move-семантика: присваивание с перемещением.

```
move assignment
assignment with move operator called
```

При записывании в уже проинициализированную переменную объекта с перемещением вызывается оператор присваивания с перемещением.

12. Вызов функции, создающей вектор из 5 элементов.

```
vector init
empty constructor called
empty constructor called
empty constructor called
empty constructor called
empty constructor called
destructor called
destructor called
destructor called
destructor called
destructor called
```

Для каждого объекта из вектора вызывается конструктор по умолчанию.
После выхода из функции все объекты уничтожаются.

13. Выход из main

```
destructor called
destructor called
destructor called
destructor called
destructor called
destructor called
destructor called
destructor called
destructor called
destructor called
```

Вызван деструктор для каждого созданного в main объекта.

## Заключение

В ходе выполнения лабораторной работы был разработан класс и определены:

- конструктор по умолчанию
- параметризированный конструктор
- конструктор копирования
- конструктор перемещения
- оператор присваивания
- оператор присваивания с перемещением

В каждом имплементированном операторе / конструкторе был добавлен debug-вывод и был написан и проанализирован тестирующий вызовы операторов / конструкторов код.